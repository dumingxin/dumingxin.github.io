[{"title":"Redisson分布式锁最佳实践","path":"/2024/07/23/Reddison分布式锁最佳实践/","content":"前言最近在使用Redisson分布式锁时遇到一个问题，代码大致如下 1234567891011121314151617public void test() &#123; String key = &quot;xxxx&quot;; RLock lock = null; try &#123; lock = redissonClient.getLock(key); boolean locked = lock.tryLock(1, TimeUnit.SECONDS); if (locked) &#123; //业务逻辑 &#125; &#125; catch (Exception ex) &#123; log.error(&quot;lock exception&quot;,ex); &#125; finally &#123; if (lock != null) &#123; lock.unlock(); &#125; &#125;&#125; 但实际上线发布之后提示锁释放失败，错误信息为attempt to unlock lock, not locked by current thread by node id仔细排查日志才发现原来是并发场景下由于获取锁失败则直接执行到finllay中的unlock方法，但是Redisson在释放锁时会校验当前线程是否持有锁，如果当前线程没有持有锁调用unlock方法时就会抛异常。正确的释放锁方式是先判断当前线程是否持有锁，然后再进行释放，正确的姿势如下 1234567891011121314151617public void test() &#123; String key = &quot;xxxx&quot;; RLock lock = null; try &#123; lock = redissonClient.getLock(key); boolean locked = lock.tryLock(1, TimeUnit.SECONDS); if (locked) &#123; //业务逻辑 &#125; &#125; catch (Exception ex) &#123; log.error(&quot;lock exception&quot;, ex); &#125; finally &#123; if (lock != null &amp;&amp; lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125; &#125; &#125; 在释放之前添加对锁状态以及当前线程是否持有锁的判断，然后再进行释放。使用分布式锁的基本套路是先尝试获取锁，获取成功之后执行业务逻辑，最后释放锁，同时为了避免业务异常导致锁没有及时释放，整个代码要使用try&#x2F;catch&#x2F;finaly包裹起来，代码写起来非常啰嗦。所以本着让我们的代码更加优雅，我们可以进行简单的封装处理，在有场景需要使用时只需要关注锁的粒度、等待时间和业务逻辑处理即可，不需要关心锁的获取和释放细节，参考代码如下 1234567891011121314151617181920212223242526272829@Component@Slf4jpublic class RedissonLockPlus &#123; @Autowired private RedissonClient redissonClient; public void tryLock(String key, Long time, TimeUnit timeUnit, Runnable lockedCallback, Runnable unLockCallback) &#123; RLock lock = null; try &#123; lock = redissonClient.getLock(key); boolean locked = lock.tryLock(time, timeUnit); if (locked) &#123; if (lockedCallback != null) &#123; lockedCallback.run(); &#125; &#125; else &#123; if (unLockCallback != null) &#123; unLockCallback.run(); &#125; &#125; &#125; catch (Exception ex) &#123; log.error(&quot;lock exception&quot;, ex); &#125; finally &#123; if (lock != null &amp;&amp; lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125; &#125; &#125;&#125; 在实际使用时代码就会变得很清晰 12345678public void test() &#123; String key = &quot;xxxx&quot;; redissonLockPlus.tryLock(key, 1L, TimeUnit.SECONDS, () -&gt; &#123; //获取锁成功业务逻辑 &#125;, () -&gt; &#123; throw new RuntimeException(&quot;获取锁失败&quot;); &#125;);&#125; 当然我们也可以自定义一个分布式锁的注解，然后通过切面进行锁的获取和释放，这种方式更优雅，但使用时要注意避免内部调用免得切面不生效，网上有类似做法，我这里就不赘述了 总结本文主要介绍了使用分布式锁常见的一些问题，避免大家重复踩坑。同时也提供了一种优雅的分布式锁的使用方式，希望对大家有所帮助。"}]