[{"title":"Reddison分布式锁最佳实践","path":"/2024/07/23/Reddison分布式锁最佳实践/","content":"前言最近在使用Reddison分布式锁时遇到一个问题，代码大致如下 1java 但实际上线发布之后提示锁释放失败，仔细排查日志才发现原来是并发场景下由于获取锁失败则直接执行到finllay中的unlock方法，但是reddison在释放锁时会校验当前线程是否持有锁，如果当前线程没有持有锁调用unlock方法时就会抛异常。正确的释放锁方式是先判断当前线程是否持有锁，然后再进行释放，正确的姿势如下 1java 本着举一反三的原则我又搜一下工程中其他使用分布式锁的姿势，于是发现了下面各种姿势的代码 11 12 13 使用分布式锁的基本套路是先尝试获取锁，获取成功之后执行业务逻辑，最后释放锁，同时为了避免业务异常导致锁没有及时释放，整个代码要使用try&#x2F;catch&#x2F;finaly包裹起来，代码写起来非常啰嗦。所以本着让我们的代码更加优雅，我们可以进行简单的封装处理，在有场景需要使用时只需要关注，key的生成和业务逻辑处理即可，不需要关心锁的释放，参考代码如下 1封装代码 当然我们也可以自定义一个分布式锁的注解，然后通过切面进行锁的获取和释放，这种方式更优雅，但使用时要注意避免内部调用免得切面不生效，网上有类似做法，我这里就不赘述了 总结本文主要介绍了使用分布式锁常见的一些问题，避免大家重复踩坑。同时也提供了一种优雅的分布式锁的使用方式，希望对大家有所帮助。"}]